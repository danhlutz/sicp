(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ 1 low) high))))

(define (flatmap proc seq)
  (fold-right append '() (map proc seq)))

(define (list-ref alist n)
  (cond ((null? alist) 
         (error "no more list" n))
        ((= n 0) (car alist))
        (else (list-ref (cdr alist) (- n 1)))))

(define (loop times)
  (if (= times 2)
      (flatmap (lambda (i)
                 (map (lambda (j) (list i j))
                      (enumerate-interval 1 5)))
               (enumerate-interval 1 5))
      (flatmap (lambda (k)
                 (map (lambda (l) (cons k l))
                      (loop (- times 1))))
               (enumerate-interval 1 5))))

(define (distinct? alist)
  (cond ((null? alist) true)
        ((memq (car alist) (cdr alist)) false)
        (else (distinct? (cdr alist)))))

(define (meets-requirements? alist)
  (let ((baker  (car alist))
        (cooper (cadr alist))
        (fletch (caddr alist))
        (miller (cadddr alist))
        (smith  (car (cddddr alist))))
    (cond ((not (distinct? alist)) false)
          ((= baker 5) false)
          ((= cooper 1) false)
          ((= fletch 5) false)
          ((= fletch 1) false)
          ((< miller cooper) false)
         ;((= (abs (- smith fletch)) 1) false)
          ((= (abs (- fletch cooper)) 1) false)
          (else true))))

(define (multiple-dwelling)
  (map (lambda (alist)
         (list (list 'baker (car alist))
               (list 'cooper (cadr alist))
               (list 'fletch (caddr alist))
               (list 'miller (cadddr alist))
               (list 'smith (car (cddddr alist)))))
       (filter meets-requirements? (loop 5))))
