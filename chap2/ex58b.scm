(define (deriv exp var)
  (newline)
  (display "in deriv with exp: ")
  (display exp)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        ((exponentiation? exp)
         (make-product
           (make-product (exponent exp)
                         (make-exponentiation (base exp)
                                              (- (exponent exp) 1)))
           (deriv (base exp) var)))
        (else 
          (error "unknown expression type -- DERIV" exp))))

(define (variable? x) (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (=number? exp num)
  (and (number? exp) (= exp num)))

; (define (make-sum a1 a2)
;  (cond ((=number? a1 0) a2)
;        ((=number? a2 0) a1)
;        ((and (number? a1) (number? a2)) (+ a1 a2))
;        (else (list a1 '+ a2))))

(define (make-sum . terms)
  (newline)
  (display "in make-sum with terms: ")
  (display terms)
  (define (iter term-list number symbols)
    (cond ((or (not (list? term-list)) (= (length term-list) 0))
           (append (list number) symbols))
          ((number? (car term-list))
           (iter (cdr term-list) (+ number (car term-list)) symbols))
          (else (iter (cdr term-list) 
                      number 
                      (append symbols 
                              (list '+ (car term-list)))))))
  (let ((new-sum (iter terms 0 ())))
    (newline)
    (display "new-sum")
    (display new-sum)
    (if (= (length new-sum) 1)
        (car new-sum)
        (let ((number (car new-sum))
              (symbols (augend new-sum)))
          (cond ((= (length new-sum) 1) number)
                ((= number 0) symbols)
                (else new-sum))))))

(define (make-product . terms)
  (newline)
  (display "in make-product with terms: ")
  (display terms)
  (define (iter term-list number symbols)
    (cond ;((not (pair? term-list)) (list number '* term-list))
          ((= (length term-list) 0) (append (list number) symbols))
          ((number? (car term-list))
           (iter (cdr term-list) (* number (car term-list)) symbols))
          (else (iter (cdr term-list) 
                      number 
                      (append symbols (list '* (car term-list)))))))
  (let ((new-prod (iter terms 1 ())))
    (newline)
    (display "new-product")
    (display new-prod)
    (let ((number (car new-prod))
          (symbols (multiplicand new-prod)))
    (cond ((= number 0) 0)
          ((null? symbols) number)
          ((= number 1) symbols)
          (else new-prod)))))

;(define (make-product m1 m2)
;  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
;        ((=number? m1 1) m2)
;        ((=number? m2 1) m1)
;        ((and (number? m1) (number? m2)) (* m1 m2))
;        (else (list m1 '* m2))))

(define (sum? x)
  (and (pair? x) (eq? (cadr x) '+) (not (memq '*  x))))

(define (addend s) 
  (newline)
  (display "In added with s: ")
  (display s)
  (car s))

(define (augend s)
  (newline)
  (display "in augend with s: ")
  (display s)
  (newline)
  (display "length s: ")
  (display (length s))
  (newline)
  (display "caddr s: ")
  (display (caddr s))
  (cond ((not (list? s)) ())
        ((< (length s) 3) ())
        ((< (length s) 4) (caddr s))
        (else 
          (newline)
          (display "in else")
          (let ((new-augend (memq '+ s)))
            (newline)
            (display "new-augend")
            (display new-augend)
            (if (= (length new-augend) 2)
                (cadr new-augend)
                (cdr new-augend))))))
; (if (not (pair? s))
;      ()
;      (let ((new-augend (cddr s)))
;        (if (= (length new-augend) 1)
;            (car new-augend)
;            new-augend))))

(define (product? x)
  (and (pair? x) (pair? (memq '* x))))

(define (multiplier p)
  (newline)
  (display "in multiplier with p: ")
  (display p)
  (define (iter terms result)
    (if (eq? (car terms) '*)
        result
        (iter (cdr terms) (append result (list (car terms))))))
  (let ((new-multiplier (iter p ())))
    (if (= (length new-multiplier) 1)
        (car new-multiplier)
        new-multiplier)))

(define (multiplicand p)
  (newline)
  (display "in multiplicand with p: ")
  (display p)
  (cond ((not (list? p)) ())
        ((< (length p) 3) ())
        ((< (length p) 4) (caddr p))
        (else 
          (let ((new-multiplicand (cdr (memq '* p))))
            (if (= (length new-multiplicand) 1)
                (car new-multiplicand)
                new-multiplicand)))))
;  (if (not (pair? p))
;      ()
;      (let ((new-multiplicand (cdr (memq '* p))))
;        (if (= (length new-multiplicand) 1)
;            (car new-multiplicand)
;            new-multiplicand))))

(define (exponentiation? x)
  (and (pair? x) (eq? (car x) '**)))

(define (make-exponentiation u n)
  (cond ((=number? n 0) 1)
        ((=number? n 1) u)
        (else (list '** u n))))

(define (base p) (cadr p))

(define (exponent p) (caddr p))
